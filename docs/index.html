<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="template-css.css" type="text/css" />
</head>
<body>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">
        <ul>
          <li class="nav-header">Table of Contents</li>
        </ul>
        <ul>
        <li><a href="#feb22012-programming-code-quality-guide">FEB22012 Programming Code Quality Guide</a><ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#mandatory-rules">Mandatory Rules</a></li>
        <li><a href="#important-rules-error-prone-coding">Important Rules: Error Prone Coding</a></li>
        <li><a href="#indications-of-sloppy-code">Indications of sloppy code</a></li>
        </ul></li>
        </ul>
        </div>
      </div>
            <div class="span9">
            <h1 id="feb22012-programming-code-quality-guide">FEB22012 Programming Code Quality Guide</h1>
<h2 id="introduction">Introduction</h2>
<p>This document contains the code quality guide that we use during the FEB22012(X) Programming course.</p>
<h2 id="mandatory-rules">Mandatory Rules</h2>
<p>A number of rules are mandatory in the sense that we do not award any points for code quality and style if these are violated. This is only a small set of rules you have to adhere to. Most of these rules are all related to writing proper Javadoc comments, but there are three other rules: a <code>.java</code> file should contain a single top-level class, you should refrain from using mutable <code>public</code> instance variables and if you override either <code>hashCode()</code> or <code>equals()</code>, you should also override the other.</p>
<p>Relevant Rules regarding Javadoc:</p>
<ul>
<li><a href="https://checkstyle.sourceforge.io/config_javadoc.html#InvalidJavadocPosition">InvalidJavadocPosition</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_javadoc.html#JavadocMethod">JavadocMethod</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_javadoc.html#JavadocType">JavadocType</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_javadoc.html#MissingJavadocMethod">MissingJavadocMethod</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_javadoc.html#MissingJavadocType">MissingJavadocType</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_javadoc.html#NonEmptyAtclauseDescription">NonEmptyAtclauseDescription</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_design.html#VisibilityModifier">VisibilityModifier</a></li>
</ul>
<p>Relevant Rules regarding general programming:</p>
<ul>
<li><a href="https://checkstyle.sourceforge.io/config_coding.html#EqualsHashCode">EqualsHashCode</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_design.html#OneTopLevelClass">OneTopLevelClass</a></li>
<li><a href="https://pmd.github.io/pmd-6.17.0/pmd_rules_java_bestpractices.html#missingoverride">MissingOverride</a></li>
</ul>
<h3 id="proper-javadoc-comments">Proper Javadoc Comments</h3>
<p>You should write Javadoc comments to document public <em>classes</em> and <em>methods</em>. It is not allowed to write Javadoc comments in other locations. Regular comments are allowed. The following code fragment contains some examples:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">  <span class="at">@Override</span>
  <span class="co">/**</span>
   <span class="co">*</span> This JavaDoc comment should be before the <span class="co">@</span>Override annotation<span class="co">,</span> not here<span class="co">.</span>
   <span class="co">*/</span>
   <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compare</span>(MyClass o1, MyClass o2) {
      <span class="co">/**</span>
      <span class="co">*</span> Javadoc comments should never be written inside methods<span class="co">!</span>
      <span class="co">*/</span> 
      <span class="co">// Regular single line comments are allowed anywhere</span>
      <span class="co">/* Multi-line regular comments</span>
<span class="co">       * are also allowed anywhere</span>
<span class="co">      */</span>
      <span class="kw">return</span> o1.<span class="fu">getValue</span>() - o2.<span class="fu">getValue</span>();
   }
}</code></pre></div>
<p>Your classes should always contain Javadoc with a <code>@author</code> tag that starts with your ERNA-id. For example, a correct (but too short) class Javadoc could look as follows:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">/**</span>
 <span class="co">*</span> This class does some very interesting stuff<span class="co">.</span>
 <span class="co">*</span>
 <span class="co">*</span> <span class="kw">@author </span><span class="co">123456ae</span> Adrian Example
 <span class="co">*/</span>
<span class="kw">public</span> <span class="kw">class</span> MyClass {

}</code></pre></div>
<p>Finally, you should use tags such as <code>@param</code> and <code>@return</code> in your Javadoc comments to explain the meaning of parameters and returned values of your methods and constructors. If you define a tag in a Javadoc comment, you are not allowed to leave the explanation empty.</p>
<h3 id="make-instance-variables-private">Make instance variables private</h3>
<p>A well designed class should not burden its users with details of its implementation. You have probably worked with objects of the String class, but you do not necessarily know all the details of how it is implemented by the programmers of the Java language. A common way to do this, it to make sure all interactions with objects of a class are performed using methods of that class, while the internal data model (i.e. the instance variables) of the objects are hidden from the users. This referred to as <a href="https://en.wikipedia.org/wiki/Information_hiding">information hiding</a> or <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">encapsulation</a>.</p>
<p>As a consequence, you should define all instance variables or class members as <code>private</code>.</p>
<p>**Note :* in certain exercises, this requirement may be relaxed to some extent. If so, this is mentioned in the text of the exercise.</p>
<h3 id="single-top-level-class">Single Top Level class</h3>
<p>You are only allowed to have a single top-level class in a <code>.java</code> file. The following code fragment gives an example of a file with two top-level classes.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Foo{
  <span class="co">//methods</span>
}

<span class="kw">class</span> Foo2{
  <span class="co">//methods</span>
}</code></pre></div>
<p>If you want to have more than a single class in a file, you can consider to create <em>static inner classes</em>. This can be done as follows:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Foo{
  <span class="co">//methods</span>
  
  <span class="dt">static</span> <span class="kw">class</span> Foo2{
  <span class="co">//methods</span>
  }

}</code></pre></div>
<h3 id="override-both-hashcode-and-equals">Override both hashCode and equals</h3>
<p>This rule becomes relevant when you are introduce to inheritance and the <code>Object</code> class; it is not likely you will violate it before you understand these concepts. It basically means that as soon as a class override either the <code>hashCode()</code> or <code>equals()</code> method, it should also override the other one. It is almost always incorrect to override only one of them according to the contracts of these methods.</p>
<h3 id="override-annotation-is-mandatory">Override annotation is mandatory</h3>
<p>When you learn how to implement an interface or extend a class, you may want to override methods. When you override a method, you should always use the <code>@Override</code> annotation, since it avoids that you accidentally introduce a new method while you intend to override something. For example, you want to override a method <code>doAnalysis()</code> but accidentally call the method in the subclass <code>analysis()</code>. With the <span class="citation">@Override</span> annotation, the compiler will warn you that you made a mistake, that is usually hard to find by debugging.</p>
<p>Annotating overridden methods with <span class="citation">@Override</span> ensures at compile time that the method really overrides one, which helps refactoring and clarifies intent. For example:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Foo <span class="kw">implements</span> <span class="bu">Comparable</span>&lt;Foo&gt; {
                <span class="co">// This method is overridden, and should have an @Override annotation</span>
                <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compareTo</span>(Foo other) {

                }
            }</code></pre></div>
<h2 id="important-rules-error-prone-coding">Important Rules: Error Prone Coding</h2>
<p>The second set of rules are <em>error prone</em> coding rules. If these issues are detected in your code, it will have a strong impact on your score for code quality. While it is technically possible to use violate these rules in correct code, in almost all cases these things are mistakes, or can quickly lead to mistakes if you need to change your code at a later moment. Therefore, you should avoid doing these things.</p>
<p>Relevant rules:</p>
<ul>
<li><a href="https://checkstyle.sourceforge.io/config_blocks.html#AvoidNestedBlocks">AvoidNestedBlocks</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_blocks.html#EmptyCatchBlock">EmptyCatchBlock</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_blocks.html#NeedBraces">NeedBraces</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_coding.html#HiddenField">HiddenField</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_coding.html#InnerAssignment">InnerAssignment</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_coding.html#SimplifyBooleanExpression">SimplifyBooleanExpression</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_coding.html#SimplifyBooleanReturn">SimplifyBooleanReturn</a></li>
</ul>
<h3 id="avoid-nested-blocks">Avoid Nested Blocks</h3>
<p>In Java, you are allowed to define loose blocks, that have their own scope. The following code fragment contains a loose block:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">printSomething</span>() {
   <span class="dt">int</span> x = <span class="dv">3</span>;
   {
      <span class="co">// This is a loose block, which you should avoid.</span>
     <span class="dt">int</span> x = <span class="dv">5</span>;
   }
   <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;The number is &quot;</span>+x);
   
   <span class="co">// This block belong to an-if statement, and is allowed.</span>
   <span class="kw">if</span> (x &lt; <span class="dv">5</span>) {
      <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Smaller than 3&quot;</span>);
   }
   
   <span class="co">// The accidental semi-colon seperates the if statement</span>
   <span class="co">// from the block. This is the type of mistake we like</span>
   <span class="co">// to avoid.</span>
   <span class="kw">if</span> (x==<span class="dv">5</span>); <span class="co">// notice the semi-colon!!</span>
   {
      <span class="co">// Oops! This part is always executed, not matter</span>
     <span class="co">// what the value of x is.</span>
     <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;x seems to be five&quot;</span>);
   }
}</code></pre></div>
<h3 id="avoid-empty-catch-blocks">Avoid Empty Catch Blocks</h3>
<p>In Java, empty <code>catch</code> blocks are considered bad practice since they suppress mistakes, while the user of your program may want to know that something went wrong. You should never catch an Exception if you have no good way to deal with. At the very least, you should print a stacktracte using the <code>e.printStackTrace()</code> on the <code>Exception</code> object <code>e</code>. Alternatively, you can throw the exception to a caller. Consider the following code fragments:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">readFileInBadWay</span>(<span class="bu">File</span> input) {
   <span class="kw">try</span> {
     <span class="bu">List</span>&lt;<span class="bu">String</span>&gt; allLines = Files.<span class="fu">readAllLines</span>(input.<span class="fu">toPath</span>());
   }
   <span class="co">// The following catch-block is empty; you should avoid this.</span>
   <span class="kw">catch</span> (<span class="bu">IOException</span> ex) {
     
   }
}

<span class="kw">public</span> <span class="dt">void</span> <span class="fu">readFileInBetterWay</span>(<span class="bu">File</span> input) {
   <span class="kw">try</span> {
     <span class="bu">List</span>&lt;<span class="bu">String</span>&gt; allLines = Files.<span class="fu">readAllLines</span>(input.<span class="fu">toPath</span>());
   }
   <span class="co">// The following catch-block at least gives a message to the user.</span>
   <span class="co">// This is allowed</span>
   <span class="kw">catch</span> (<span class="bu">IOException</span> ex) {
     <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Error reading file &quot;</span>+input);
    ex.<span class="fu">printStackTrace</span>();
   }
}

<span class="co">// Since our caller should provide an input file that we can read properly,</span>
<span class="co">// in this case the best design is to let the caller of this method deal</span>
<span class="co">// with the IOException if the file can not be read.</span>
<span class="kw">public</span> <span class="dt">void</span> <span class="fu">readFileInBestWay</span>(<span class="bu">File</span> input) <span class="kw">throws</span> <span class="bu">IOException</span> {
   <span class="bu">List</span>&lt;<span class="bu">String</span>&gt; allLines = Files.<span class="fu">readAllLines</span>(input.<span class="fu">toPath</span>());
}</code></pre></div>
<h3 id="control-structures-need-braces.">Control-structures need braces.</h3>
<p>The Java language allows you to write a single statement after control structures such as <code>if</code>, <code>for</code> and <code>while</code>. That means no block is defined using <code>{</code> and <code>}</code>, and only a single statement is affected by the control structure. Since this is often error prone, this should be avoided. The following code fragments contains some examples:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">for</span> (<span class="dt">int</span> x=<span class="dv">0</span>; x &lt; <span class="dv">10</span>; x++)
   <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;The number is &quot;</span>+x);

<span class="kw">if</span> (x&gt;<span class="dv">3</span>)
   <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Greater than three&quot;</span>);
   
<span class="kw">while</span> (x&lt;<span class="dv">10</span>)
   <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;The number is &quot;</span>+x);
   <span class="co">// The following line of code is executed only after the loop finishes!</span>
   <span class="co">// This is a type of mistake we prefer to avoid!</span>
   x++;</code></pre></div>
<p>The correct version of the above code fragment looks as follows:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">for</span> (<span class="dt">int</span> x=<span class="dv">0</span>; x &lt; <span class="dv">10</span>; x++)
{
   <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;The number is &quot;</span>+x);
}

<span class="kw">if</span> (x&gt;<span class="dv">3</span>)
{
   <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Greater than three&quot;</span>);
}
   
<span class="kw">while</span> (x&lt;<span class="dv">10</span>)
{
   <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;The number is &quot;</span>+x);
   <span class="co">// Now this is executed in every iteration of the loop.</span>
   x++;
}</code></pre></div>
<h3 id="avoid-shadowing-variables">Avoid shadowing variables</h3>
<p>A variable can have a different scope, depending on the location is where it is defined. Variables defined within the class are instance variables and are part of objects, while variables defined as parameters of method or constructors only live while that method or constructor is executed. We should avoid using the same name at different levels within the same class if this causes potential confusing, as the class level variable is hidden/shadowed. The following fragment contains an example of instance variable shadowing:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> MyClass {

   <span class="kw">private</span> <span class="dt">int</span> someNumber;
   <span class="kw">private</span> <span class="dt">int</span> anotherNumber;
   
   <span class="kw">public</span> <span class="fu">MyClass</span>(<span class="dt">int</span> someNumber, <span class="dt">int</span> anotherNumber) {
      <span class="co">// This assigns a new value to the parameter, but not to the instance variable!!</span>
     <span class="co">// This is likely a mistake</span>
     someNumber = anotherNumber + <span class="dv">5</span>;
     anotherNumber = someNumber + <span class="dv">3</span>;
   }
}</code></pre></div>
<p>The constructor mentioned can be written as follows:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">   <span class="kw">public</span> <span class="fu">MyClass</span>(<span class="dt">int</span> firstNumber, <span class="dt">int</span> secondNumber) {
     someNumber = secondNumber + <span class="dv">5</span>;
     anotherNumber = firstNumber + <span class="dv">3</span>;
   }</code></pre></div>
<p>Alternatively, the following is allowed as well:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">   <span class="kw">public</span> <span class="fu">MyClass</span>(<span class="dt">int</span> someNumber, <span class="dt">int</span> anotherNumber) {
     <span class="co">// With the explicit this reference, the can be no confusion!</span>
     <span class="kw">this</span>.<span class="fu">someNumber</span> = anotherNumber + <span class="dv">5</span>;
     <span class="kw">this</span>.<span class="fu">anotherNumber</span> = someNumber + <span class="dv">3</span>;
   }</code></pre></div>
<h3 id="refrain-from-using-inner-assignments">Refrain from using inner assignments</h3>
<p>In programs we often want to update the value of variable. We should always do this using an assignment statement, for example <code>x = 5;</code>, <code>x++;</code> or <code>x -= 2;</code>. However, in the syntax of Java assignments are also considered expressions. Thus something like <code>x = (y = 5) + 3;</code> is also valid, and assigns the value <code>5</code> to variable <code>y</code> and the value <code>8</code> to variable <code>x</code>. These constructs are error-prone, and often lead to mistakes, in particular when accidentally used in an <code>if</code> or <code>while</code> construction. For example, the following code fragment never terminates:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">boolean</span> doSomeMore = <span class="kw">true</span>;
<span class="co">// The assignment in the condition always sets doSomeMore to true, and thus the condition</span>
<span class="co">// is always true and the loop never terminates!</span>
<span class="kw">while</span> (doSomeMore = <span class="kw">true</span>) {
   <span class="fu">doSomething</span>();
   <span class="fu">checkSomething</span>();
}</code></pre></div>
<h3 id="simplify-boolean-expressions">Simplify Boolean Expressions</h3>
<p>It is helpful to keep the condition <code>if</code> statement, or a method with a <code>boolean</code> return value simple. This means that if use a <code>boolean</code> expression in those contexts, we should avoid comparing this expression against <code>true</code> or <code>false</code>.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">boolean</span> checkValue = <span class="fu">checkSomething</span>();
<span class="co">// The comparison is not necessary!</span>
<span class="kw">if</span> (checkValue == <span class="kw">true</span>) {
   <span class="co">// do something</span>
}

<span class="co">// This can be simplified to</span>
<span class="kw">if</span> (checkValue) {
   <span class="co">// do something</span>
}</code></pre></div>
<p>Something similar holds for methods that return a boolean value. Since we can return arbitrary restrictions, we can return boolean expressions rather than unnecessary <code>if</code> and <code>else</code> constructs, as the following code fragment illlustrates.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">boolean</span> checkValue = <span class="fu">checkSomething</span>();
<span class="kw">if</span> (checkValue == <span class="kw">false</span>) {
   <span class="kw">return</span> <span class="kw">true</span>;
}
<span class="kw">else</span> {
   <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="co">// The above fragment can be simplified to a single line:</span>
<span class="kw">return</span> !<span class="fu">checkSomething</span>();</code></pre></div>
<h2 id="indications-of-sloppy-code">Indications of sloppy code</h2>
<p>These rules are not necessarily error prone, but they look sloppy or are distracting to other programmers when they want to read your code. It makes code more difficult to understand, and therefore more difficult to spot bugs in the code.</p>
<p>Relevant rules:</p>
<ul>
<li><a href="https://checkstyle.sourceforge.io/config_blocks.html#EmptyBlock">EmptyBlock</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_coding.html#EmptyStatement">EmptyStatement</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_coding.html#IllegalThrows">IllegalThrows</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_coding.html#IllegalCatch">IllegalCatch</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_coding.html#IllegalType">IllegalType</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_imports.html#UnusedImports">UnusedImports</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_misc.html#TodoComment">TodoComment</a></li>
<li><a href="https://checkstyle.sourceforge.io/config_misc.html#UncommentedMain">UncommentedMain</a></li>
</ul>
<h3 id="avoid-empty-blocks">Avoid Empty Blocks</h3>
<p>Empty blocks are typically an indication the structure of your program can be improved or simplified. They distract from the actual logic of your program. Therefore, you should avoid these. Often, empty blocks that may seem <em>logical</em> can be avoided by rewriting <code>boolean</code> expressions. For example. the following pattern:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> x = <span class="fu">computeX</span>();
<span class="dt">int</span> y = <span class="fu">computeY</span>();
<span class="co">// The first block is empty</span>
<span class="kw">if</span> (x &gt; <span class="dv">5</span> &amp;&amp; y &lt; <span class="dv">25</span> &amp;&amp; x &gt; y) {
}
<span class="kw">else</span> {
   <span class="fu">doSomething</span>();
}</code></pre></div>
<p>can be rewritten to the more consise and less error prone:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> x = <span class="fu">computeX</span>();
<span class="dt">int</span> y = <span class="fu">computeY</span>();
<span class="co">// We can use a negation to remove the empty block</span>
<span class="kw">if</span> (!(x &gt; <span class="dv">5</span> &amp;&amp; y &lt; <span class="dv">25</span> &amp;&amp; x &gt; y)) {
   <span class="fu">doSomething</span>();
}</code></pre></div>
<p>Note that empty methods or constructors are allowed, as these are sometimes necessary or useful and can not always be avoided.</p>
<h3 id="avoid-empty-statements">Avoid Empty Statements</h3>
<p>Empty statement do nothing, and are therefore clutter in your code. They are causes by having unnecessary semi-colons and should be avoided. The following code fragment contains an example:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="co">// Note the double semi-colon that results in an empty statement.</span>
<span class="dt">int</span> b = <span class="dv">3</span>+<span class="dv">5</span>;;</code></pre></div>
<h3 id="avoid-catching-or-throwing-exception-types-that-are-too-general">Avoid catching or throwing exception types that are too general</h3>
<p>When you catch an exception, you should catch an exception that is specific enough. Exception types that are too general, should not be could. Therefore, it is not allowed to catch exception of type <code>Error</code>, <code>Exception</code>, <code>Throwable</code> or <code>RuntimeException</code>. Similar, you should not define method headers that mention one of these exception types after the <code>throws</code> keyword. If you catch exceptions that are too general, there is a risk that you catch exceptions you did not expect: this can make debugging a lot more complicated (in particular if the exception is ignored). If your method throws exceptions of a type that is too general, it is highly likely the users of that method do not have enough information about the potential causes of that exception, and what they can do to avoid or handle those exceptions.</p>
<h3 id="collections-api-use-the-interfaces-as-types">Collections API: use the interfaces as types</h3>
<p>When you start working with the Collections API, you should declare variables of the various Collections types by their interface type, rather than use explicit class types. So, <code>List</code>, <code>Set</code>, <code>Map</code>, <code>SortedSet</code> and <code>SortedMap</code> are preferred over <code>ArrayList</code>, <code>HashSet</code>, <code>HashMap</code>, etc. The reason is that it should be easy to change the implementation of your data structure. The following code-fragment contains variables that are not defined by the correct interface type:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> MyClass {
   
   <span class="co">// This is not allowed</span>
   <span class="kw">private</span> <span class="bu">ArrayList</span>&lt;<span class="bu">String</span>&gt; lines;

   <span class="kw">public</span> <span class="fu">MyClass</span>() {
      <span class="co">// It is always allowed (and in fact necessary) to call the constructor</span>
     <span class="co">// of concrete Collections API types.</span>
      <span class="kw">this</span>.<span class="fu">lines</span> = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();
   }
   
   <span class="kw">public</span> <span class="dt">void</span> <span class="fu">doSomething</span>() {
      <span class="co">// The type of this variable is also not an interface type</span>
      <span class="bu">TreeSet</span>&lt;<span class="bu">String</span>&gt; mySet = <span class="kw">new</span> <span class="bu">TreeSet</span>&lt;&gt;();
   }
}</code></pre></div>
<p>To fix this example, it should be as follows:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> MyClass {
   
   <span class="co">// The correct interface type is List</span>
   <span class="kw">private</span> <span class="bu">List</span>&lt;<span class="bu">String</span>&gt; lines;

   <span class="kw">public</span> <span class="fu">MyClass</span>() {
      <span class="co">// It is always allowed (and in fact necessary) to call the constructor</span>
     <span class="co">// of concrete Collections API types.</span>
      <span class="kw">this</span>.<span class="fu">lines</span> = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();
   }
   
   <span class="kw">public</span> <span class="dt">void</span> <span class="fu">doSomething</span>() {
      <span class="co">// For a TreeSet, we can use either Set or SortedSet as the interface type.</span>
      <span class="bu">SortedSet</span>&lt;<span class="bu">String</span>&gt; mySet = <span class="kw">new</span> <span class="bu">TreeSet</span>&lt;&gt;();
   }
}</code></pre></div>
<h3 id="avoid-defining-unused-imports">Avoid defining unused imports</h3>
<p>Having import statements that are never used result in warnings from Eclipse and the Java compiler. This is sloppy, useless code, which we should remove from a <code>.java</code> file. In Eclipse it is possible to use a feature called <em>Organize imports</em> (under the <em>Source</em> menu, or with ctrl+shift+O) that automatically removes any unused imports from a file.</p>
<h3 id="remove-todo-and-auto-generated-comments">Remove TODO and auto-generated comments</h3>
<p>If your comments contains <code>TODO:</code> or <code>generated method stub</code>, this indicates that your code is not neatly finished. Thus, this is not allowed in your final submission.</p>
<h3 id="only-define-a-main-method-in-classes-that-have-a-name-ending-with-main">Only define a main method in classes that have a name ending with Main</h3>
<p>Often it is useful to define <code>main</code> methods in classes to test whether they work as expected or not. In your final code, however, it is best to litter classes with testing code that is irrelevant to the user of that class. Therefore, only classes that are designed to contain a <code>main</code> method to be used by the end-user should contain a <code>main</code> method. These classes should have a name that ends with <code>Main</code>.</p>
<p>Note that in the assignments of FEB22012 Programming, you are typically not required to hand in your own <code>main</code> method, unless this is stated otherwise.</p>
            </div>
    </div>
  </div>
</body>
</html>
